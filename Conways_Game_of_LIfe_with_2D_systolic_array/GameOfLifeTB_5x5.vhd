--Entity Name: 
-- 	GameOfLifeTB_5x5
--
--Description: 
-- 	This is a testbench for Conway's Game of Life for 5x5 grid. (MESH_SIZE = 5)
--  The patterns and testvectors for this testbench are generated by using Python.
--  It verifies the cellular automata with different initial patterns. For each pattern, it checks the change of
--  states over NUM_EPOCHS epochs. At every epoch, the testbench verifies if the transition of states on the grid
--  are all correct.
--  The patterns tested in this testbench are
--
--  Initial Pattern 0: Blinker
--  Initial Pattern 1: Boat
--  Initial Pattern 2: Glider
--  Initial Pattern 3: Stabilizer (it turns into BeeHive and stabilizes)
--  Initial Pattern 4: Death
--  Initial Pattern 5: FullSquare
--  Initial Pattern 6: Random
--  Initial Pattern 7: CornerEdge (Explicitly test corners and edges)
--  
--  The initial pattern vector is shifted in to the array in the reverse order, and the output data is verified 
--  with the testvectors in the same order as well.
--
--  Note that all possible cases of different situations (neighbors = 0, 1, ..7, 8) are fully covered throughout 
--  the testbench for 5x5 grid, the testbench for 6x6 grid, and the testbench for 12x12 grid.
--
--Revision History
--	03/10/2019	Sung Hoon Choi	Created
--  03/11/2019  Sung Hoon Choi  Initial simulation
--  03/12/2019  Sung Hoon Choi  Added more initial patterns and testvectors to cover different cases
--  03/14/2019  Sung Hoon Choi  Updated comments


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity GameOfLifeTB is
end GameOfLifeTB;

architecture Behavioral of GameOfLifeTB is

-- Top-level entity to be verified
component GameOfLife is
generic(MESH_SIZE: natural := 5);
port(
    Clk: in std_logic;
    NextTimeTick: in std_logic;
    Shift: in std_logic;
    DataIn: in std_logic;
    DataOut: out std_logic
    );
end component;

-- The size of the mesh to be tested
constant TEST_MESH_SIZE : natural := 5;
-- The total number of cells
constant GRID_SIZE: natural := TEST_MESH_SIZE**2;

-- System clock
signal Clk: std_logic := '1';
-- When active, cells change the state based on the rule on the clock rising edge
signal NextTimeTick: std_logic := '0';
-- When active, cells shift data on the clock rising edge
signal Shift: std_logic := '0';
-- Data to be shifted in to the array
signal DataIn:std_logic;
-- Data to be shifted out from the array
signal DataOut:std_logic;
-- Notifies the end of simulation
signal END_SIM:std_logic := '0';

-- Number of epochs to verify the change of patterns over time
constant NUM_EPOCHS : natural := 6;
-- Number of initial patterns to be tested
constant NUM_PATTERNS : natural := 8;

-- Type definition for the testvectors that verify the change of patterns over different epochs
type GameOfLifeTestVecType is array(0 to NUM_EPOCHS-1) of std_logic_vector(0 to GRID_SIZE-1);

-- Blinker (Oscillates, period: 2)
signal Blinker: std_logic_vector(0 to GRID_SIZE-1) := "0000000100001000010000000";
-- Blinker test vectors
signal BlinkerTestvector: GameOfLifeTestVecType := (  "0000000000011100000000000", -- epoch 1
                                                      "0000000100001000010000000", -- epoch 2
                                                      "0000000000011100000000000", -- epoch 3
                                                      "0000000100001000010000000", -- epoch 4
                                                      "0000000000011100000000000", -- epoch 5
                                                      "0000000100001000010000000");-- epoch 6
                                                      
-- Boat (Stays still)                                       
signal Boat: std_logic_vector(0 to GRID_SIZE-1) := "0000001100010100010000000";
-- Boat testvectors
signal BoatTestvector: GameOfLifeTestVecType := ( "0000001100010100010000000", -- epoch 1
                                                  "0000001100010100010000000", -- epoch 2
                                                  "0000001100010100010000000", -- epoch 3
                                                  "0000001100010100010000000", -- epoch 4
                                                  "0000001100010100010000000", -- epoch 5
                                                  "0000001100010100010000000");-- epoch 6
                                                  
-- Glider that keeps moving to right with transformation
signal Glider: std_logic_vector(0 to GRID_SIZE-1) := "0100000100111000000000000";
-- Glider testvectors
signal GliderTestvector: GameOfLifeTestVecType := (  "0000010100011000100000000", -- epoch 1
                                                     "0000000100101000110000000", -- epoch 2
                                                     "0000001000001100110000000", -- epoch 3
                                                     "0000000100000100111000000", -- epoch 4
                                                     "0000000000010100011000100", -- epoch 5
                                                     "0000000000000100101000110");-- epoch 6
                                                     
-- Stabilizes to BeeHive at 3rd epoch                                        
signal Stabilizer: std_logic_vector(0 to GRID_SIZE-1) := "0000000000011100100000000";
-- Stabilizer testvectors
signal StabilizerTestvector: GameOfLifeTestVecType := ( "0000000100011000100000000",  -- epoch 1
                                                      "0000001100011000110000000", -- epoch 2
                                                      "0000001100100100110000000", -- epoch 3
                                                      "0000001100100100110000000", -- epoch 4
                                                      "0000001100100100110000000", -- epoch 5
                                                      "0000001100100100110000000");-- epoch 6

-- Dies at 5th epoch
signal Death: std_logic_vector(0 to GRID_SIZE-1) := "1000001110000000000000000";
-- Death testvectors
signal DeathTestvector: GameOfLifeTestVecType := (  "0110001100001000000000000", -- epoch 1
                                                    "0110000010011000000000000", -- epoch 2
                                                    "0010000010001000000000000", -- epoch 3
                                                    "0000000110000000000000000", -- epoch 4
                                                    "0000000000000000000000000", -- epoch 5
                                                    "0000000000000000000000000");-- epoch 6											
                                                     
-- Full Square
signal FullSquare: std_logic_vector(0 to GRID_SIZE-1) := "1111111111111111111111111";
-- FullSquare testvectors
signal FullSquareTestvector: GameOfLifeTestVecType := ( "1000100000000000000010001", -- epoch 1
													    "0000000000000000000000000", -- epoch 2
													    "0000000000000000000000000", -- epoch 3
													    "0000000000000000000000000", -- epoch 4
													    "0000000000000000000000000", -- epoch 5
													    "0000000000000000000000000");-- epoch 6

-- Random
signal Random: std_logic_vector(0 to GRID_SIZE-1) := "1110011110111100100001000";				
-- Random testvectors
signal RandomTestVector: GameOfLifeTestVecType := ( "1001000000000100000000000", -- epoch 1
													      "0000000000000000000000000", -- epoch 2
													      "0000000000000000000000000", -- epoch 3
													      "0000000000000000000000000", -- epoch 4
													      "0000000000000000000000000", -- epoch 5
													      "0000000000000000000000000");-- epoch 6	
														  
-- Corners and Edges
signal CornerEdge: std_logic_vector(0 to GRID_SIZE-1) := "1101110001100001000111011";
-- CornerEdge testvectors
signal CornerEdgeTestVector: GameOfLifeTestVecType := ( "1101110011110001001111011", -- epoch 1
														"1111100011111000001111111", -- epoch 2
														"0110100001011000000101101", -- epoch 3
														"0001000000000100000000010", -- epoch 4
													    "0000000000000000000000000", -- epoch 5
													    "0000000000000000000000000");-- epoch 6	
begin
	-- Instantiate the entity to verify
    UUT: GameOfLife 
        generic map(MESH_SIZE => TEST_MESH_SIZE)
        port map(
            Clk => Clk,
            NextTimeTick => NextTimeTick,
            Shift => Shift,
            DataIn => DataIn,
            DataOut => DataOut
            );


-- Generate the system clock
Clk <= not Clk after 50 ns;


-- Go through testing different initial patterns. 
-- Check the correctness at every epoch. (Epoch1: states after 1 tick / Epoch2: states after 2 ticks / ..)
-- Between every epoch it resets the grid to test new epochs.
-- It shifts in the data into array by using the pattern vectors in the reverse order. 
-- For every test routine, it shifts out the data from the array and compare the data with the testvectors in the
-- reverse order.
-- After going thorugh all NUM_PATTERNS test cases (and NUM_EPOCHS test epochs for each pattern), it sets the
-- END_SIM signal to notify that the simulation is done.
process
begin
    DataIn <= '0';
	-- Wait before starting the simulation
    wait for 80 ns;
	-- Start testing NUM_PATTERNS initial patterns
    for pattern in 0 to NUM_PATTERNS-1 loop
		-- Outer loop to test the cellular automata at every epoch
        for epoch in 0 to NUM_EPOCHS-1 loop
			-- Shift in the initial pattern
            Shift <= '1';
            for i in 0 to GRID_SIZE-1 loop
                if(pattern = 0) then
                    DataIn <= Blinker(GRID_SIZE-1-i); -- Shift in initial pattern 0
                elsif(pattern = 1) then
                    DataIn <= Boat(GRID_SIZE-1-i);    -- Shift in initial pattern 1
                elsif(pattern = 2) then
                    DataIn <= Glider(GRID_SIZE-1-i);  -- Shift in initial pattern 2
                elsif(Pattern = 3) then
                    DataIn <= Stabilizer(GRID_SIZE-1-i); -- Shift in initial pattern 3
                elsif(Pattern = 4) then
                    DataIn <= Death(GRID_SIZE-1-i);   -- Shift in initial pattern 4
				elsif(Pattern = 5) then
					DataIn <= FullSquare(GRID_SIZE-1-i); -- Shift in initial pattern 5
				elsif(Pattern = 6) then
					DataIn <= Random(GRID_SIZE-1-i); -- Shift in initial pattern 6
				elsif(Pattern = 7) then
					DataIn <= CornerEdge(GRID_SIZE-1-i); -- Shift in initial pattern 6
                end if;
                wait for 100 ns;
            end loop;
			-- Since we are done with shifting in the initial pattern, let's run the cellular automata
            Shift <= '0';
			-- Activate the NextTimeTick based on the epoch
			-- For example, if epoch=1, activate NextTimeTick for one cycle
			--              if epoch=2, activate NextTimeTick for two cycles
             for tick in 0 to epoch loop
                 NextTimeTick <= '1';
                 wait for 100 ns;
             end loop;
			-- Since we are done with running the cellular automata, let's shift out the data to check if the 
			-- result is correct
            NextTimeTick <= '0';
            Shift <= '1';
            for i in 0 to GRID_SIZE-1 loop
				-- Compare the result with the testvector (pattern 0)
                if(pattern = 0) then
                    assert(std_match(DataOut, BlinkerTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;   
				-- Compare the result with the testvector (pattern 1)
               elsif(pattern = 1) then
                    assert(std_match(DataOut, BoatTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;      
			    -- Compare the result with the testvector (pattern 2)
               elsif(pattern = 2) then
                    assert(std_match(DataOut, GliderTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;    
				-- Compare the result with the testvector (pattern 3)
               elsif(pattern = 3) then
                    assert(std_match(DataOut, StabilizerTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;       
				-- Compare the result with the testvector (pattern 4)
               elsif(pattern = 4) then
                    assert(std_match(DataOut, DeathTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;  
				-- Compare the result with the testvector (pattern 5)
               elsif(pattern = 5) then
                    assert(std_match(DataOut, FullSquareTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;  
				-- Compare the result with the testvector (pattern 6)
               elsif(pattern = 6) then
                    assert(std_match(DataOut, RandomTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR; 
				-- Compare the result with the testvector (pattern 7)
               elsif(pattern = 7) then
                    assert(std_match(DataOut, CornerEdgeTestVector(epoch)(GRID_SIZE-1-i)))
                    report "Error: DataOut does not match the expected value at pattern number " 
							& integer'image(pattern)
                        severity ERROR;  						
               end if;     
                wait for 100 ns;
            end loop;  
        end loop;   
    end loop; 
	-- Simulation complete
	END_SIM <= '1';
    wait;
end process;

end Behavioral;
